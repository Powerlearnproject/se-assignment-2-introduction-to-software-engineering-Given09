[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15226242&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2
Assignment: Introduction to Software Engineering
Instructions:
Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropriate.

Questions:
Define Software Engineering:

Software Engineering is a systematic approach to designing, developing, testing and maintaining of high quality software systems.

What is software engineering, and how does it differ from traditional programming?

Software engineering is the systematic application of engineering principles, tools and methods to a succesful development and maintanace of high quality software system.

Differences between traditional programming and software engineering

(a)Complexity: Software engineering does involve the use of complex computer science and engineering principles to construct a software structure. BUT Programmers focus only on technical coding.

(b)Responsbilities: Software engineers are responsible for the entire software development lifecycle from design to maintenance WHILE Progammers are primarily focused on writing code.

(c)Iterative nature: Software engineering always follows an iterative development process, where software is oftenly improves based on user feedback WHEREAS Traditional programming follow quite a more linear process, where designs can be finalized before construction begins.

(d)Tangibility: Traditional engineering deal with  pphysical objects like buildings, roads BUT Software Engineering on the contrary  focuses on creating intangible ptoducts like computer programs and applications. 

Software Development Life Cycle (SDLC):


Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase.

Phases of software Development cycle include:

(a) Requirement - This is the first phase that requires gathering and documenting client's system requirements and and analyzing them for feasibility.

(b)Design - In this phase,the software's architecture is designed according to the requirements

(c)Implementation - The design is then implemented by writing code and starting to build the software.

(d)Testing - The software is later tested to ensure that it meets the specifiedrequirements and does not have any bugs.

(e)Deployment - After testing, the software  is later deployed in the production environment 

(f)Maintanance - Post-deployment, there must be provided support to maintain the software and ensure it stays updated and functional

Agile vs. Waterfall Models:

Agile is an iterative and incremental software development methodology which is focused on collaborative efforts and responding to changes. Agile is featured with division of tasks into short work periods. For example assembling a car where you build a certain functionality, test it and then improve it in the next iteration.

Waterfall model is a linear sequential model where by each phase must be completed before the next one starts. It follows a sequence, just like building a house where each and every step is completed in order. Starting from the foundation, frame and so on

Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?

Comparisons

(a)Focus on customer satisfaction: As agile places a stronger emphasis on customer collaboration and feedback throughout the development process, on the other hand, waterfall also aims at satisfying customer needs. Both have their focused aimed at the customer

(b)Importance of Testing: Both methodologies understand the importance of testing in ensuring the software quality. Despite they differ in timing and approach. For example; Waterfall conducts testing after development is complete, but Agile executes testing through out each iteration.

(c)Documentation: Both methodologies require some level of documentation to communicate project requirements , designs, and other important information with the clients 

(d)Structural approach: Both methodologies provide a structured framework for organizing and managing the software development process. That is there are defined distinct phases and activities to guide teams through the life cycle of the project.

Differences

(a)Delivery time
-Agile projects often have shorter delivery times due to their iterative nature. Agile delivers a series of wins overtime WHILE waterfall projects have longer delivery times due to the fact that entire project is planned and executed sequentially. Where by a delay in one phase can impact the entire project timeline. It does deliver a single final product.

(b)Flexibility: Agile is very flexiblle as it can welcome changes even late during the development process. This allows customers feedback and enabling the product to evolve based on changing requirements WHILE Waterfall is rigid (less flexible) and difficult to accomodate changes in requirements once the project has started.

(c)Approach: Agile is an iterative and incremental approach that emphasizes on flexibility delivering rapidly, since it breaks the project into small iterations hence allowing for continous feedback and adaptation throughout the software development cycle WHILE Waterfall follows a linear sequential approach where each phase must be completed before moving on to the next one. Its rigidly structured with requirements defined upfront and difficult to accomodate changes once the development begins

Requirements Engineering:

What is requirements engineering? Describe the process and its importance in the software development lifecycle.

Requirements engineering is a critical process in software development that involves analyzing, documenting and managing the requirements of a software system. 

Process involved in Requirements Engineering:

(a)Requirement Elicitation: This involves identifying, gathering and unerstanding the needs of stakeholders who will interact with the system software. Methods like interview, surveys and observation are used here.

(b)Requirement modelling: It involves creating a model of the software system that represents the requirements gathered during elicitation process. It can be in form of chart, diagram.

(c)Requirement Analysis: This stage involves analyzing the requirements gathered during elicitation process to identify any ambiguities. Also it involves the functional and non-functional requirements of a software system.

(d)Requirements verification: The stage involves verifying that the software system meet the requirements gathered during elicitation process and verifying that the requirements are correct and complete

(e)Requirement Management: The stage involves managing system software requirements throughout the development process. It includes tracking changes to requirements and ensuring that the requirements remain updated and aligned with objective goals.

Imortance of Requirement Engineering in Software Development lifecycle

(a)Improved communication: Through Requirement Engineering, it strengthens communications among stakeholders byy providing clear and concise understanding of the requirements.

(b)Risk reduction: Requirement Engineering helps in reducing the risk of error and defects by ensuring that the software system meets the requirements.

(c)Quality improvement: Requirement Engineering helps to improrve the quality of the softare system by ensuring that it meets the requirements and is not defected.

(d)Increased customer satisfaction: By ensuring that the software systems meet the needs and expectations of customers, requirement engineering has played a great role.

Software Design Principles:

Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems?

Modularity is a crucial design principle in software engineering aimed at creating software in a way that minimizes dependencies among the system components.

How modularity improves maintainability and scalability of software systems

(a)Ease of reading: Software becomes more readable as it is separated into specific functions handling distinct aspects of the overall functionality.

(b)Code organization: Grouping similar functions into libraries and files makes finding specific code easy and development can be streamlined.

(c)Focus on s ystem: Through modularity, it can be easy for developers to focus on individual system parts without affecting the entire system, therefore enhancing development efficiency.

(d)Simple testing: It is very easy and straightfoward to conduct testing, detailed when focusing on smaller, singular-function models. 
(Secoda)

Testing in Software Engineering:

Testing in software engineering is a crucial process that ensures the quality, functionality and reliability of software products.

Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). Why is testing crucial in software development?

Levels of software engineering

(a)Unit testing: This is a software testing method perfomed by developers where individual units or components of a software are tested with the main purpose of verifying that each unit of the software performs as expected. Its main focus is on the smallest testable parts of a software. Tools used include Junit, NUnit. Example of unit testing; Testing a function that calculates the addition of two numbers to ensure it returns the correct answer.

(b)Intergration testing is a level of software testing perfomed by developers or testers where individual units are combined and tested as a group. It mainly focuses on the interaction between intergrated components. Tools used include TestNG, JUnit. Example of intergrated testing; Testing the interaction between user authentification module and user profile module.

(c)System testing is a level of software testing by the testing team where a complete, intergrated system is tested as a whole to verify the complete and intergrated software system against specified requirements. It largely focuses on the wole system fubctionality and perfomance. Tools used include Jmeter, Selenium. Example of a system testing; Testing a mobile banking app to ensure that it handles user transactions and also can process payments correctly.

(d)Acceptance testing is a level of software testing conducted by Quality Assurance team, clients to determine whether the system meets the business requirements and is  ready for delivery to end-users. It mainly focus on business and user requirements. Tools used include Manual test cases, custom scripts. Example of acceptance testing; Quality assurance engineer testing a new feature in banking app to ensure it meets the requirements of the users before deploment.

Version Control Systems:

What are version control systems, and why are they important in software development? Give examples of popular version control systems and their features.

Version control systems are software tools used to track changes to code, documentation, and other files over time and coordinating work among team members.

Importance of version control system

(a)They allow multiple people to work on a project simultaneously without interfering with each other's work, keep track of changes and revert to the previous versions where necessary.

(b)Acts as a backup for storing every version of the project so that even if it happens that the local files are lost or something goes wrong, the project can still be recovered.

(c)Developers can experiment with new ideas in isolated branches without imposing an effect on the main project. If the experiment is succesful, it can be intergrated to the main project and if not, it can be discarded without inputting any risk to the main project.

(d)It keeps detailed history of all changes, hence making it easy to understand the project evolution and contributors accountable for their work. 

(e)It allows developers to track changes to code, documents and other files over time. Therefore being able to review what changes were made and when they were made.

Examples of popular version control systems and their features.

(a)Git - This is a flexible and speedy distributed version control system which allows branching and merging and more over facilitating collaborative development workflow. It has powerful tools to track changes and managing reepositories.

(b)Subversion - This is a centralized version control system that tracks changes to files and directories over time. It also allows branching but its braching model is less effective compared to Git. It has features like atomic commits which ensures either all changes in a commit are applied or none of them are.

(c)Mercurial- This is a distributed version control system similar to git since it offers many featuresas it Git does, including branching, merging and distributed development. Mercurial is very simple in terms of use hence a better choice to both big and small projects.

Software Project Management:

Discuss the role of a software project manager. What are some key responsibilities and challenges faced in managing software projects?

 Roles of a Software Project Manager
 (a)Risk management- Identifies potential risks and develops mitigation strategies to encounter the risks in case they tend to occur. They determine issues that may impact the project and deploy plans to minimize thr risks.

 (b)Communication facilitation- Project managers facilitate communication among team members and stakeholders to ensure that everyon eis informed about project progress, changes and decisions also addressing any concerns raised by stakeholders

 (c)Leadership and motivation- Project managers lead their teams to achieve the project goals. They do provide guidance, support to members and advocating for collaboration to create a positive work environment that encourages creativity

 (d)Budgeting and cost management- Project managers are accountable for controlling costs. They track expenses and oversee budget utilizationand and making adjustments as necessary to ensure the project remains within budget constraints.

 (e)Quality assurance- Project managers ensure the quality of the software product since they define quality standards, establish testing process and monitor the quality of the deliverables throughout the project. They coordinate with the quality assurance team addressing defects and ensure that the final product meets the client's expectations.

 Challenges faced in managing software projects

(a)Rigid deadlines and budget constraint: Completing software projects in a timely manner while staying  within budget is a long-time challenge that results to delay and rising up unexpected costs.

(b)Unclear goals and objectives:  Getting clear on what you need to do is pretty critical for successful completion of projects. Failure to do so results to na wholw host of issues including poor resource and stakeholder management.

(c)Lack of focus: We can refer  this to how the requirements of a project change from what was originally agreed at project initiation, therefore this clearly can bring about a drawback within the whole process of software project.

(d)Lack of communication: Communication is the main bridge that builds or breaks a project. Good communication means that team members work welltogether and task allocated efficiently and also stakeholders are put in loop about the project progress. Bad communication means none of the above.

(e)Poor risk management skills: Project managers have a role to play in evaluating and managing risks throughout the life cycle of their projects. Risks are always there to occur no matter how much you plan, however skills in risk mitigating strategies are essential in reducing the impacts of these risks.

Software Maintenance:

Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle?
Ethical Considerations in Software Engineering:

Software maintanance is the process of modifying (making changes) and updating a software system after it has been delivered to the customer.

Types of Maintenance activities;

(a)Adaptive mainenance: This is concerned with software modifications that occur in order to make the software adaptable to new environments and hence making sure that the software remains compatible and functional in different environments. For example running a software on a different operating system.

(b)Corrective maintenance: This is cooncerned with error fixing mostly the errors that are observed when the software is in use. It aims at rectifying faults and errors in the software and making sure that it functions correctly. For example using a banking software and you find that it is diffiult to login. 

(c)Preventive maintenance: This is concerned with taking measures to prevent software problems from occuring. It aims at reducing the probability of errors and downtime, hence ensuring that the software remains stable and reliable

(d)Perfective maintenance: This is concerned with enhancing the software to improve its perfomance, functionality and more over its usability. It involves adding more features, modifying the existing ones to meer changing user requirements. For example a mobile network app earlier it had no a feature to buy bundles from the app directly, perfective maintenance can be deployed to add that feature.

What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?

Ethical issues that software engineer might face

(a)Transparency and accountability: Software engineers should strive to make their algorithm and decison-making processes transparent. Users should be able to understand how decisions are made

(b)Privacy and data security: Software engineers usually tend to work with sensitive user data. Ensuring the privacy and security of this data is crucial. Ethical issues do arise right from the point data is collected, stored or used without consent.

(c)Intellectual property: Respect for intellectual proprerty rights is essential in software development. Software engineers must be mindful of copyright and licensing issues when using third-party code.

(d)Accessibility: Ensuring that software is accessible to all users including the disabled ones. Engineers should strive to design and develop a software that is inclusive and usable by everyone.

(e)Bias and Fairness: Software engineers need to be vigilant about identifying and mitigating bias in their code in order to ensure fair treatment to all users. Bias can be inadversely introduced into algorithms and software systems leading to unfair outcomes.

How software engineers can adhere to ethical standards in their work:

(a)Familiarizing oneself with the code of ethics; There are principles that as a software engineer, you must adhere to. These principles are related to the behaviour and decisoions made by software engineer.

(b)Consider the impact of your work: Before commencing a project, software engineers should consider the impact of their work in the society which includes both positive effects of their decisions and decisions.

(c)Adherence to professional standards:Software engineers should adhere to professional standards like the ones outlined in the code of ethics to ensure that their work meets the highest standards of quality and integrity

(d)Promote accessibility: Software engineers must ensure they create accessible softwares that do not discriminate against individuals based on race, religion, age, disability.

(e)Continual learning and improvement: Learning has no end, software engineers also should keep learning to improve their skills and knowledge to stay updated with the latest ethical standards and practices in field.
(IEEE-Computer society)

Submission Guidelines:
Your answers should be well-structured, concise, and to the point.
Provide real-world examples or case studies wherever possible.
Cite any references or sources you use in your answers.
Submit your completed assignment by [due date].
